---
layout: post
title: 利用modbus协议实现主从设备通信（二）———— Modbus分析
discription: 
tags: linux
---
  其实对于Modbus协议的文档中，已经做了详细的描述，我暂且把我认为重要的一些内容记下来吧！  

 一、主从协议原理
=====
  主设备发出命令，从设备接收并返回相应的应答数据。  
>  单播：从设备接收地址1~247  
>  广播：从设备接收地址0，必须全部被动接收  

 二、地址规则
=====
  0          1~47       55~248  
广播地址 子节点单独地址  保留  

 三、帧描述
=====
  MODBUS PDU协议包含功能域，数据域,如：  
> 功能域 数据域  

  MODBUS PDU串行链路通信协议在MODBUS PDU的基础上增加了地址域与校验两个附加域,如：  
> 地址域 功能域 数据域 冗余校验（CRC或LRC）  

###地址域：就是从设备地址,见地址规则  
###功能域：  
  主->从：告知从设备执行操作  
  从->主：回复正常或异议  
> exp：  
>   主从：功能代码0000 0011  
>   正常 从主：功能代码0000 0011  
>   异议 从主：功能代码1000 0011  
                       ^  
                异议时逻辑位置一  
  异议时，从设备将特殊代码放入数据段进行回复  
###数据域：  
  指定起始寄存器与选中寄存器数目  
###错误检测域：  
  ASCII:LRC纵向冗长检测  
  RTU:CRC循环冗长检测  
  检测时只检测有效消息长度  

四、传输模式
=====
###ASCII传输模式:  
  以：（也就是0x3A）为该帧传输起始位  
  以回车换行符为（0x0D，0x0AH）为结束  

  起始  设备地址 功能代码   数据        LRC校验 结束符   
  1字符  2字符   2字符    0~2x252字符    2字符  2字符  

  注：1个ASCII字符=8bit数据  

  因此总数据大小<=513字符  

####ASCII 模式每个字节 ( 10 位 ) 的格式为 :  
 编码系统:  
> 十六进制,ASCII 字符 0-9, A-F。  
> 报文中每个 ASCII 字符含有 1 个十六进制字符  
 Bits per Byte:  
> 1 起始位  
> 7 数据位, 首先发送最低有效位  
> 1 位作为奇偶校验  
> 1 停止位  

###RTU传输模式:  
  以3.5个字符时间间隔表示起始  
  以4个字符时间间隔表示结束  

  起始          设备地址 功能代码   数据     LRC校验     结束符  
  4字符时间长度   8bit    8bit      n个8bit   2个8bit 4字符时间长度   
    
  注：T3.5 = 3.5×（1+数据位+奇偶校验位+停止位）/波特率,不过后来也用不到了，，，，  
 
####RTU 模式每个字节 ( 11 位 ) 的格式为 :
  编码系统:  
>  8–位二进制  
> 报文中每个 8 位字节含有两个 4 位十六进制字符(0–9, A–F)  
  Bits per Byte:  
>  1 起始位  
>  8 数据位, 首先发送最低有效位  
>  1 位作为奇偶校验  
>  1 停止位  

  注：对于ASCII与RTU对每个字节的传输格式了解即可，那是用来配置串口通信参数要用到的，但我还曾天真的想
  每个字节为什么会是11位这个中格式，字节不是只有八位吗  
  后来才领会他的本意，原来是将八位数据封装成十一位数据格式发送，事实上通过硬件接口与硬件传输通道发过去
  的只是数据流，我猜想串口驱动会将数据流进行处理，才使得我们的数据能以8位的格式从/dev/ttyS0正确获取到  

  注：还有一项要注意的我已经吃过亏了，通常无奇偶校验时需要把奇偶校验位换成一个停止位，加上本应存在的一个
  停止位，共两个停止位。但是，一些从设备无奇偶校验时，也不需要把他替换为停止位。所以形成了8N1,7N1，无奇偶
  校验+1停止位这种模式。

####这篇也算是对当时学习modbus资料的一点总结吧，有什么不对的地方，也请各位斧正！
